1 - Handling Disjunctions and Full Set of Mixed Constraints

Notes: To precisely handle disjunctions we need to encode every variable into automaton. This will probably not be an efficent way. We will make improvements by loosing precision or by selecting a subset of variables (automatically or manually) that we are interested in solving/counting. Note that we do not need to combine string and integer automaton unless there is a disjunction.

Automata Construction Tasks:
 ! Add a cache for commonly constructed DFAs and Automata.

  1- Refactor automaton classes: Generate a set of MONA related automaton methods to use in automata construction. Mona C++ wrapper function names starts with "DFA" prefix.

  2- Combine "RelationalStringAutomaton" and "StringAutomaton" classes into one class called "StringAutomaton". A single variable string automaton will be equivalent to a relational string automaton with one variable. This will allow as to handle mixed constraints in a better way. See item 5.

  4- Replace the usage of "IntAutomaton" with "UnaryAutomaton".

  3- Combine "IntegerAutomaton" and "IntAutomaton" classes into one class called "IntAutomaton". Only have binary representation here.

  4- Add support for boolean variables. Create a boolean automaton or use IntAutomaton.

  5- Add a library wrapper class as a singleton. Inherit specific libraries and add methods that needs to be implemented in those libraries.

  6- Add Builder class for all static methods, inherit specific builders from builder class (for integer, unary, string) or add build methods for each type.

  7 - Item 5 and 6 is a combination of Factory and Builder patterns. this->Builder()....build() is a pattern to construct an automaton.

  9 - Implement a track map, or formula class that each automaton has as a member where variable to track map is kept. Extend formula/track map class per automaton type as needed, remove current formula

  10 - create a stats class to collect the status information for each method call with params. Use it for further optimizations, cache decision.

  11 - Add a cache class to cache dfas for the builder operations.
  
  12 - Add a mixed automaton class that combines all types of automaton into one. That will be mainly used for OR operations.
Solver Tasks:
  1- Make sure disjucntions are not treated as a component.
  2- Using the refactoring automata construction create a disjunct automata that contains all variables under disjunction.
  3- Handle mixed constraint as defined in the baki's dissertation.



2- Improvements:

Notes: We may need to use some other automaton library. Make it easy to change underlaying automaton representation.

Tasks:
1- Define an abstract class that declares a set of automata related methods.
2- Define an abstract builder class that declares a set of automata construction methods.
3- Move underlaying automata related functions into a separate class that inherits from the class defined in task 1.
3- Implement a builder for each underlaying automata construction support.
